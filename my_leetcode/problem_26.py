# -*- coding: utf-8 -*-
# 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

# 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

# 示例 1:

# 给定数组 nums = [1,1,2], 

# 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

# 你不需要考虑数组中超出新长度后面的元素。

def removeDuplicates(nums):
    if nums == []:
        return 0
    lens = 0 # 去重后的元素个数(也是独立元素对应的在原数组里的正确位置)，默认0，当循环判断每发现一个不同的元素，
    # 这个值就+1（所以最后返回时要再加+1，因为漏掉了第一个元素）
    tmp = nums[lens] # 这个变量代表当前最新的独立的新变量，初始从原数组第一个元素开始
    # 每次循环，判断tmp与下一个元素是否相等，并且比较tmp元素与当前元素是否一致，
    # 如果tmp与下一个元素不相等，说明下一个元素是新的独立元素，此时将下一个元素赋值给tmp变量，
    # 并且将下一个元素赋值给原数组的第 lens+1 的位置上，此时将lens自加1，这样保持跟tmp元素的值与位置是匹配的
    ##################
    # 总结：循环判断相邻的元素是否独立的元素。如果是独立元素，就要将其赋值到原先数组的“正确”位置。
    #      这时就需要一个变量(lens)来表示这是第几个独立元素，他的正确位置在哪儿,
    #      还需要一个临时变量来存储 最新的独立元素，就是tmp

    for i in range(len(nums)-1):
        if tmp != nums[i+1] and nums[i] == tmp:  # 交换
            nums[lens+1] = nums[i+1]
            tmp = nums[i+1]
            lens+=1
    return lens+1

# aa=[1,1,1,2,2,4,5,6]
aa=[1,1,1,2,3,4,5,6]
# [1,2,1,2,2,4,5,6]
print (removeDuplicates(aa))
print (aa)

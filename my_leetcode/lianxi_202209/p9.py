# -*- coding: utf-8 -*-

# 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
# 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
# 例如，121 是回文，而 123 不是。

# 思路1：
# 思路上跟 p7 题目有点类似，都需要取余，比较第一个数字和最后一个数字是否相等（也就是将数字取反然后判断是否相等）
# 思路2：
# 可以只曲一半的数字进行取反，然后判断跟另一半部分是否相等，如果相等就说明是回文数


def is_huiwen_num(num):
    # 首先判断数字是否为负数、大于0的正数且个位是0（能被10整除的）
    if num<0 or (num>0 and num%10==0):
        return False

    
    # 接下来截取原数字的后半部分，可以除以10取余，上一轮的余数*10加上本轮的余数作为我们反转的那一半数字，然后对原数字除以10取整
    # 继续上述的步骤，循环截止的条件就是我们已经处理完了一半数字了，一个核心的思路就是处理后的原数字 <= 处理后的反转数字
    # （关键点就是原数字的位数在变小-每次除以10，而反转数字的位数在变多-每次乘以10）

    reve_num = 0 # 初始化一个 反转数字 
    # 开始循环，结束条件就是 原数字 <= 反转数字 
    while num <= reve_num:
        reve_num = reve_num*10 + num%10
        num = num // 10
    
    # 当原数字是偶数位时，只要处理后的原数字与反转数字相等就是回文数，
    # 如果是奇数位，处理后的反转数字比原数字多一位（多了中间的那一位数字）,这时候除以10取整在判断是否相等
    if num == reve_num or num == reve_num//10:
        return True
    else:
        return False


